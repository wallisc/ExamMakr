package qsolutions.exam;

import java.io.*;
import org.openide.util.lookup.ServiceProvider;
import qsolutions.api.DocumentItemApi;
import qsolutions.api.DriverApi;
import qsolutions.api.ExamApi;
import qsolutions.api.QuestionApi;

/**
 * This class serves as a utility class in that it stores various static methods
 * usable by multiple other classes.
 *
 * @author michaelmease
 */
@ServiceProvider(service = DriverApi.class)
public class Driver implements DriverApi 
{

    private final static int kEndBodyTag = 6;
    private final static String kEndPaTag = "<p style=\"margin-top: 0\">";

    /**
     * Removes indexes from an array that represent DesignItem indexes.
     *
     * @param indexes An array of item indexes
     * @param exam The Exam containing items associated with these indexes
     * @return A new array containing now DesignItem indexes
     */
    public int[] removeDesignItemIndexes(int[] indexes, ExamApi exam) 
    {
        //The array of Question indexes
        int[] newIndexes;
        //The count of questions in the exam at the given indexes
        int questionCount = 0;
        //The current index of newIndexes
        int newIndex = 0;
        //Get the number of questions at the given indexes
        for (int index = 0; index < indexes.length; index++) 
        {
            //If the current item is at an index in indexes, add one to count
            if (exam.getItemAt(indexes[index]) instanceof QuestionApi) 
            {
                questionCount++;
            }
        }
        newIndexes = new int[questionCount];
        //For each question at an index within indexes, add it to newIndexes
        for (int index = 0; index < indexes.length; index++) 
        {
            //If the current item is at an index in indexes, add one to count
            if (exam.getItemAt(indexes[index]) instanceof QuestionApi) 
            {
                newIndexes[newIndex] = indexes[index];
                newIndex++;
            }
        }
        return newIndexes;
    }

    /**
     * Saves the exam into a given file using serialization.
     *
     * @param testToSave The exam to save into a file
     * @param file The File to save the Exam into
     */
    public void saveTest(ExamApi testToSave, File file) 
    {
        Exam exam = (Exam) testToSave;
        FileOutputStream fos;
        ObjectOutputStream out;
        try 
        {
            fos = new FileOutputStream(file);
            out = new ObjectOutputStream(fos);
            out.writeObject(exam);
            out.close();
        } 
        catch (IOException except) 
        {
            System.err.println("IOException occurred.");
        }
        catch (NullPointerException ex) 
        {
            System.err.println("\"file\" was null.");
        }
    }

    /**
     * Loads a exam from a given file if the file exists. @pre File must exist
     * or else a NullPointException results
     *
     * @param file The File to load from
     * @return The exam loaded from the file
     */
    public ExamApi loadTest(File file) 
    {
        Exam exam = null;
        FileInputStream fis;
        ObjectInputStream in;
        try 
        {
            fis = new FileInputStream(file);
            in = new ObjectInputStream(fis);
            exam = (Exam) in.readObject();
            in.close();
            exam.setPath(file.getPath());
        }
        catch (IOException except) 
        {
            System.err.println("Error loading from file.");
        }
        catch (ClassNotFoundException except) 
        {
            System.err.println("Object in file was not an 'exam'.");
        }
        catch (NullPointerException ex) 
        {
            System.err.println("Cannot process null files.");
        }

        return exam;
    }

    /**
     * Cleans a string generated by the getText() method from the text panels
     * using the HTMLEditorKit class.
     *
     * @param html The string from a text panel's getText() method.
     * @return A clean string containing only the text and its text format tags
     */
    public String cleanHTML(String html) 
    {

        //The string to store the eventually cleaned string
        String newString = "";
        //The start index of the text to extract
        int start;
        //The end index of the text to extract
        int end;
        try 
        {
            /*
             * start = html.lastIndexOf("<body>") + kEndBodyTag; end =
             * html.indexOf("</body>"); newString = html.substring(start, end);
             */
            newString = html.replaceAll("<(/)?(html|header|head|body)>", "");
            //If we want the pure string text

            /*start = newString.indexOf(kEndPaTag);
            end = newString.lastIndexOf("</p>");
            //If p tags found, change string
            if (start != -1 && end != -1) 
            {
                newString = newString.substring(start + kEndPaTag.length(),
                        end);
            }*/
            // If there are marks to be cleaned
                /*
             * else if (marks != -1) { // If the new string does not have <p>
             * tags if ( !(newString.contains("<p") &&
             * newString.contains("</p>")) ) { newString = "<p
             * style=\"margin-top: 0\">( " + marks + ")" + newString + "</p>"; }
             * else { newString = newString.replaceFirst("<p style=\"marg" +
             * "in-top: 0\">", "<p style=\"margin-top: 0\">(" + marks + ")"); }
            }
             */

            //newString = Driver.fixSpaces(newString);

            // remove extra spaces and newlines (replace with single space.
            newString = newString.replaceAll("\\s+", " ");
            // remove all spaces at the beginning
            newString = newString.replaceAll("^\\s+", "");

        } 
        catch (IndexOutOfBoundsException ex) 
        {
            newString = html;
        }
        return newString;
//
  //          html = html.replaceAll("<(/)?(html|header|head|body)>", "");
    //        // remove extra spaces and newlines (replace with single space.
      //      html = html.replaceAll("\\s+", " ");
        //    // remove all spaces at the beginning
           // html = html.replaceAll("^\\s+", "");
          //  
        //return html;
    }

    /**
     * Clean HTML version 2 - less forgiving
     *
     * @param html The string from a text panel's getText() method.
     * @return A clean string containing only the text and its text format tags
     */
    public String cleanHTML2(String html) 
    {

        //The string to store the eventually cleaned string
        String newString = "";
        //The start index of the text to extract
        int start;
        //The end index of the text to extract
        int end;
        try 
        {
            /*
             * start = html.lastIndexOf("<body>") + kEndBodyTag; end =
             * html.indexOf("</body>"); newString = html.substring(start, end);
             */
            newString = html.replaceAll("<(/)?(html|header|head|body)>", "");
            //If we want the pure string text

            start = newString.indexOf(kEndPaTag);
            end = newString.lastIndexOf("</p>");
            //If p tags found, change string
            if (start != -1 && end != -1) 
            {
                newString = newString.substring(start + kEndPaTag.length(),
                        end);
            }
            // If there are marks to be cleaned
                /*
             * else if (marks != -1) { // If the new string does not have <p>
             * tags if ( !(newString.contains("<p") &&
             * newString.contains("</p>")) ) { newString = "<p
             * style=\"margin-top: 0\">( " + marks + ")" + newString + "</p>"; }
             * else { newString = newString.replaceFirst("<p style=\"marg" +
             * "in-top: 0\">", "<p style=\"margin-top: 0\">(" + marks + ")"); }
            }
             */

            //newString = Driver.fixSpaces(newString);

            // remove extra spaces and newlines (replace with single space.
            newString = newString.replaceAll("\\s+", " ");
            // remove all spaces at the beginning
            newString = newString.replaceAll("^\\s+", "");

        } 
        catch (IndexOutOfBoundsException ex) 
        {
            newString = html;
        }
        return newString;
    }

    /**
     * Removes all HTML style tags from a string.
     *
     * @param htmlString The string containing tags that should be removed
     * @return The same string without tags
     */
    public static String removeAllTags(String htmlString) 
    {
        String cleanString = htmlString.replaceAll("\\<.*?>", "");
        return cleanString;
    }

    /**
     * Replaces all contiguous spaces in a String with an HTML friendly tag to
     * indicate that these spaces should be shown.
     *
     * @param htmlString The HTML String to modify.
     * @return The string containing &nbsp tags to indicate extra spaces.
     */
    @Override
    public String fixSpaces(String htmlString) 
    {
        String cleanString = htmlString.replaceAll("  ", "&nbsp;&nbsp;");
        //System.out.println(cleanString);
        return cleanString;
    }

    /**
     * Compares an item extracted from GUI with a stored exam item.
     *
     * @param extracted The extracted fields placed a new DocumentItem
     * @param item The item to compare the text to
     * @return True if the fields are equal with the data in the item
     */
    public boolean compareExtracted(DocumentItemApi extracted,
            DocumentItemApi item) 
    {
        return compareExtractedStrings(extracted.getText(), item.getText());
    }

    /**
     *
     * Compares a String extracted from GUI with a stored exam item's String.
     *
     * @param extracted The extracted String from a new DocumentItem
     * @param item The item's String to compare the text to
     * @return True if the strings are virtually equal
     */
    public boolean compareExtractedStrings(String extracted, String item) 
    {
        extracted = extracted.replaceAll("\\s", "");
        item = item.replaceAll("\\s", "");

        return extracted.equals(item)
            || (extracted.replaceAll("\\s", "")
                .matches(".*<pstyle=\"margin-top:0\"></p>.*")
            || extracted.replaceAll("\\s", "").matches(
                ".*<body></body>.*") || extracted.equals(""))
            && (item.replaceAll("\\s", "").matches(
                ".*<pstyle=\"margin-top:0\"></p>.*")
            || item.replaceAll("\\s", "").matches(
                ".*<body></body>.*") || item.equals(""));
    }
}
